import tty
import stream

extern def log10(n: Double): Double = 
  js"Math.log10(${n})"

def count_digits(number: Int): Int = {
  val n: Double = number.toDouble
  if(n == 0.0) 1
  else floor(log10(abs(n))) + 1
}
    

effect invalidInput(msg: String): Unit
effect gameOver(finalBoard: Board): Unit
effect winGame(finalBoard: Board): Unit

// custom type to represent the state of a cell of the Board
// Invariants: Player board has only Hidden, Number and Flag cells
//             Solution board has only Number and Mine cells
type CellState {
  Hidden(); // Hidden cells are only possible on the board of the player
  Number(n: Int);
  Mine(); // Mines won't be shown on the board of the player. If a cell with a mine isn't Hidden, the game is lost
  Flagged() // Flagged cells are only possible on the board of the player
}

type Board = List[List[CellState]]

type Action {
  Flag();
  Uncover()
}

type Command {
  PerformAction(a: Action,x: Int, y: Int);
  Help();
  Quit()
}

record Pos(r: Int, c: Int)
record Rule(mineCount: Int, positions: List[Pos])
type Configuration = List[Pos] // TODO use Set

def posEquals(left: Pos, right: Pos) = (left, right) match {
  case (Pos(lx, ly), Pos(rx, ry)) => lx == rx && ly == ry
}

def printRules(rules: List[Rule]): Unit = {
  var rulesString: String = ""
  rules.foreach{ rule =>
    val ruleString: String = "Rule(" ++ show(rule.mineCount) ++ ", " ++ genericShow(rule.positions) ++ ") \n" 
    rulesString = rulesString ++ ruleString
  }
  println(rulesString)
}


val helpMessage = "To make an action, type one of the following: u to uncover, f to flag/unflag, h for help and q to quit the game"
val wonMessage = """
 __     ______  _    _    __          ______  _   _  
 \ \   / / __ \| |  | |   \ \        / / __ \| \ | | 
  \ \_/ / |  | | |  | |    \ \  /\  / / |  | |  \| | 
   \   /| |  | | |  | |     \ \/  \/ /| |  | | . ` | 
    | | | |__| | |__| |      \  /\  / | |__| | |\  | 
    |_|  \____/ \____/        \/  \/   \____/|_| \_| 
                                                     
                                                     

"""

val gameOverMessage = """
 __     ______  _    _     _      ____   _____ _______      __
 \ \   / / __ \| |  | |   | |    / __ \ / ____|__   __|  _ / /
  \ \_/ / |  | | |  | |   | |   | |  | | (___    | |    (_) | 
   \   /| |  | | |  | |   | |   | |  | |\___ \   | |      | | 
    | | | |__| | |__| |   | |___| |__| |____) |  | |     _| | 
    |_|  \____/ \____/    |______\____/|_____/   |_|    (_) | 
                                                           \_\
                                                              
"""

record LengthMismatch()

def leftPadE(s: String, desiredLength: Int, padding: Char): String / Exception[LengthMismatch] = {
  val actualLength = s.length
  if (actualLength > desiredLength) {
    do raise(LengthMismatch(), "Given string is longer than desired length!")
  }

  val prefix: String = collectString {
    with replicate(desiredLength - actualLength)
    padding
  }
  prefix ++ s
}

def leftPad(s: String, desiredLength: Int, padding: Char): String = {
  val actualLength = s.length

  val prefix: String = collectString {
    with replicate(desiredLength - actualLength)
    padding
  }
  prefix ++ s
}

def leftPadZeros(n: Int, desiredLength: Int) =
  n.show.leftPad(desiredLength, ' ')


// prints the row of a board while translating the CellState Types to the corresponding string representation/symbol
// if a there aren't any mines around a cell, the field is displayed as an empty field (-)
def printRowold(row: List[CellState]): String = {
  with Formatted::formatting;
  var out: String = ""
  row.foreach{ c =>
    c match {
      case Hidden() => out = out ++ "  " ++ Formatted::colored("H", Color::BLACK)
      case Number(0) => out = out ++ Formatted::colored("  -", Color::CYAN)
      case Number(n) => out = out ++ "  " ++ show(n)
      case Mine() => out = out ++ Formatted::colored("  M", Color::YELLOW)
      case Flagged() => out = out ++ "  F".red // toString('ðŸš©') 
    }
  }
  out
}

// prints a given board in a nice way
def printBoardold(board: Board): Unit = {
  val boardsize = board.size
  var rowIndices = "    "
  var border = "  "
  each(0, boardsize) {n =>
    rowIndices = rowIndices ++ show(n) ++ "  "
    border = border ++ "---"
  }
  println(rowIndices)
  println(border)
  each(0, boardsize) {n =>
    with on[OutOfBounds].panic
    val row: List[CellState] = board.get(n)
    val s: String = printRowold(row)
    println(show(n) ++ "|" ++ s)   
  }
  println("")
}

// prints the row of a board while translating the CellState Types to the corresponding string representation/symbol
// if a there aren't any mines around a cell, the field is displayed as an empty field (-)
def printRow(row: List[CellState], cellWidth: Int): String = {
  with Formatted::formatting;
  val cW = 2  // TODO
  val space = "".leftPad(cW,' ')
  var out: String = ""
  row.foreach{ c =>
    c match {
      case Hidden() => out = out ++ Formatted::colored("H", Color::BLACK) ++ space 
      case Number(0) => out = out ++ Formatted::colored("-", Color::CYAN) ++ space
      case Number(n) => out = out ++ show(n) ++ space
      case Mine() => out = out ++ Formatted::colored("M", Color::YELLOW) ++ space
      case Flagged() => out = out ++ "F".red ++ space // toString('ðŸš©') 
    }
  }
  out
}


// prints a given board in a nice way
def printBoard(board: Board): Unit = {
  val boardsize = board.size
  val maxIndexDigits = count_digits(boardsize)
  val cellWidth: Int = maxIndexDigits + 1

  // build the header row and the header border
  var colIndices = " ".repeat(cellWidth) // TODO check for different sizes

  var border = " ".repeat(maxIndexDigits + 2)
  each(0, boardsize) {n =>
    val paddedIndex = leftPad(show(n), 3, ' ') //show(n) ++ " ".repeat(2)
    colIndices = colIndices ++ paddedIndex
    border = border ++ "-".repeat(3)
  }
  println(colIndices)
  println(border)

  // print the rows
  each(0, boardsize) {n =>
    with on[OutOfBounds].panic
    val row: List[CellState] = board.get(n)
    val s: String = printRow(row, cellWidth)

    // Pad the row index for alignment
    val paddedRowIndex = leftPad(show(n), maxIndexDigits, ' ')
    println(paddedRowIndex ++ " | " ++ s)
  }
  println("")
}

def filter[A](list: List[A]){predicate: A => Bool}: List[A] = {
  list.foldRight([]) { (elem, acc) =>
    if (predicate(elem)) Cons(elem, acc) else acc
  }
}

def main() = {
  println(show(count_digits(0)))
  println(show([1,2,3,1,4].filter{e => e > 1}))
}
