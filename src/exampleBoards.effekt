import src/fairMinesweeper
import src/utils
import src/probabilities
import src/fairRules
import io/console
import test
import tty
import stream

val exampleBoard2x2: Board = [
  [Number(0), Number(1)],
  [Flagged(), Number(0)]
]

val exampleBoard3x3: Board = [
  [Number(0), Number(2), Mine()],
  [Number(1), Number(3), Mine()],
  [Number(1), Mine(), Number(2)]
]

val exampleBoard4x4: Board = [
  [Number(0), Number(1), Mine(), Flagged()],
  [Flagged(), Number(0), Number(2), Number(3)],
  [Number(0), Number(0), Number(2), Number(0)],
  [Number(0), Flagged(), Mine(), Number(0)]
]

val examplePlayerBoard4x4: Board = [
  [Number(0), Number(1), Hidden(), Hidden()],
  [Flagged(), Number(0), Number(2), Number(3)],
  [Number(0), Number(0), Number(2), Number(0)],
  [Number(0), Flagged(), Hidden(), Number(0)]
]

val exampleSolutionBoard: Board = [
  [Number(1), Number(1), Number(1), Number(0)],
  [Number(1), Mine(), Number(1), Number(0)],
  [Number(1), Number(1), Number(2), Number(1)],
  [Number(0), Number(0), Number(1), Mine()]
]

val problematicSolutionBoard: Board = [
  [Number(0),Number(0),Number(1),Mine(),Number(3),Mine(),Mine()],
  [Number(0),Number(0),Number(1),Number(2),Number(5),Mine(),Mine()],
  [Number(0),Number(1),Number(1),Number(3),Mine(),Mine(),Mine()],
  [Number(2),Number(3),Mine(),Number(4),Mine(),Mine(), Number(4)],
  [Mine(),Mine(),Number(4),Mine(),Number(6),Mine(),Number(2)],
  [Number(4),Number(6),Number(6),Mine(),Mine(),Number(4),Number(2)],
  [Number(1),Mine(),Number(4),Mine(),Mine(),Mine(),Number(1)]
]
// problem: when uncovering (6,0), the mine on (6,1) is uncovered as well -> problem of floodfill?!
val problematicPlayerBoard: Board = [
  [Number(0),Number(0),Number(1),Hidden(),Hidden(),Hidden(),Hidden()],
  [Number(0),Number(0),Number(1),Hidden(),Hidden(),Hidden(),Hidden()],
  [Number(0),Number(1),Number(1),Number(3),Hidden(),Hidden(),Hidden()],
  [Number(2),Number(3),Flagged(),Hidden(),Hidden(),Hidden(),Hidden()],
  [Mine(),Flagged(),Number(4),Hidden(),Hidden(),Hidden(),Hidden()],
  [Number(4),Hidden(),Hidden(),Hidden(),Hidden(),Hidden(),Hidden()],
  [Hidden(),Hidden(),Hidden(),Hidden(),Hidden(),Hidden(),Hidden()]
]

val beforeRemoveMineSolution: Board = [
  [Number(1), Mine(), Number(2), Number(1)],
  [Number(2), Number(3), Mine(), Number(1)],
  [Mine(), Number(2), Number(1), Number(1)],
  [Number(1), Number(1), Number(0), Number(0)]
]

val beforeRemoveMinePlayer: Board = [
  [Number(1), Flagged(), Number(2), Hidden()],
  [Number(2), Hidden(), Hidden(), Hidden()],
  [Flagged(), Number(2), Hidden(), Hidden()],
  [Number(1), Number(1), Hidden(), Hidden()]
]

val afterRemoveMineSolution: Board = [
  [Number(2), Mine(), Number(2), Number(0)],
  [Number(3), Mine(), Number(2), Number(0)],
  [Mine(), Number(2), Number(1), Number(0)],
  [Number(1), Number(1), Number(0), Number(0)]
]

val afterRemoveMinePlayer: Board = [
  [Number(2), Flagged(), Number(2), Hidden()],
  [Number(3), Hidden(), Hidden(), Hidden()],
  [Flagged(), Number(2), Hidden(), Hidden()],
  [Number(1), Number(1), Hidden(), Hidden()]
]

val floodfillSolution: Board = [
  [Number(2), Mine(), Number(2), Number(0)],
  [Number(3), Mine(), Number(2), Number(0)],
  [Mine(), Number(2), Number(0), Number(0)],
  [Number(1), Number(1), Number(0), Number(0)]
]

val beforeFloodfillPlayer: Board = [
  [Hidden(), Hidden(), Hidden(), Hidden()],
  [Hidden(), Hidden(), Hidden(), Hidden()],
  [Hidden(), Hidden(), Hidden(), Hidden()],
  [Hidden(), Hidden(), Hidden(), Hidden()]
]

val afterFloodfillPlayer: Board = [
  [Hidden(), Hidden(), Number(2), Number(0)],
  [Hidden(), Hidden(), Number(2), Number(0)],
  [Hidden(), Number(2), Number(0), Number(0)],
  [Hidden(), Number(1), Number(0), Number(0)]
]

val probabilitiesPlayer: Board = [
  [Number(0), Number(1), Hidden(), Hidden()],
  [Number(1), Hidden(), Hidden(), Hidden()],
  [Hidden(), Hidden(), Hidden(), Hidden()],
  [Hidden(), Hidden(), Hidden(), Hidden()]
]

/*
def playMinesweeperdebug(boardSize: Int, numMines: Int): Unit = {
  var mineCount = numMines
  println("Welcome to Fair Minesweeper!")
  println("To start a new game, press Enter on your keyboard")
  var playerBoard = problematicPlayerBoard
  var solutionBoard = problematicSolutionBoard
  printBoard(playerBoard)
  try{
  printBoard(solutionBoard)

  //playerBoard = playerBoard.updateCell(firstMove.first, firstMove.second, Number(0)) // safe because we handle this move in generateSolutionBoard
  val (newPlayerBoard, _) = playerBoard.floodFill(solutionBoard, Pos(6,0), [])
  playerBoard = newPlayerBoard
  printBoard(playerBoard)

  //TODO remove
  /*println("Interesting cells: ")
  val interest = interestingCells(playerBoard)
  println(genericShow(interest))
  println(" ")
  println("Candidate cells: ")
  println(genericShow(candidateCells(playerBoard, interest)))
  val rules = generateRules(playerBoard)
  println(genericShow(calculateProbabilities(rules)))
  // 
  println(helpMessage)

  var end = false
  while(end != true){
  var commands = []
  with console;
  val action = do readLine()
  commands = commands.append([action])
  if(action == "u" || action == "f"){
    println("type the number of the row you want to make your move at")
    val x = do readLine()
    commands = commands.append([x])
    println("type the number of the col you want to make your move at")
    val y = do readLine()
    commands = commands.append([y])
  }
  val cmd = parseCommand(commands, boardSize)
  
  cmd match {
    case PerformAction(a,x,y) => try {
      try{
      val newBoards = makeMove(playerBoard, solutionBoard, Pos(x, y), a)
      playerBoard = newBoards.first
      solutionBoard = newBoards.second
      printBoard(playerBoard)} with reduceMineCount{mineCount = mineCount - 1}
    }with gameOver{b =>
    println(gameOverMessage)
    println("This is the solution board:")
    printBoard(b)
    end = true}
    case Help() => println(helpMessage)
    case Quit() => end = true//println("TODO Quit the game"); end = true
    case Rules() => val rules = generateRules(playerBoard); println(genericShow(calculateProbabilities(rules)))
    }
    if(mineCount == playerBoard.join.count{cell => cell match {
      case Number(n) => false
      case _ => true
      }})try{do winGame(playerBoard)} with winGame{b => println(wonMessage)}
  }} with invalidInput{m => println(m); resume(())}
}*/

def main() = {
  /*printBoard(problematicSolutionBoard)
  printBoard(problematicPlayerBoard)
  val ffres = floodFill(problematicPlayerBoard,problematicSolutionBoard,Pos(6,0),[])
  printBoard(ffres.first)*/
  //playMinesweeperdebug(7,22)
  // 
  def assertPosSetEqual(firstList: List[Pos], secondList: List[Pos]): Unit/{Assertion, Formatted} = {
    var bothEqual = false
    if(not(firstList.isEmpty)){
      bothEqual = true
      firstList.foreach{p1 =>
        bothEqual = bothEqual && secondList.any{p2 => p1.posEquals(p2)}
      }
    }
    do assert(bothEqual, "the two lists don't contain the exact same elements")
  }

  def assertProbSetEqual(firstList: List[(Pos, Double)], secondList: List[(Pos, Double)]): Unit/{Assertion, Formatted} = {
    var bothEqual = false
    if(not(firstList.isEmpty)){
      bothEqual = true
      firstList.foreach{el1 =>
        bothEqual = bothEqual && secondList.any{el2 => el1.first.posEquals(el2.first) && el1.second.equals(el2.second)}
      }
    }
    do assert(bothEqual, "the two lists don't contain the exact same elements")
  }

  // test if removing a mine from (1,2) to (1,1) works correctly for an example game state
  println(suite("test main functions"){
    test("countAdjacentMines") {
      var countingCorrect = true
      exampleBoard3x3.foreachIndex { (rowIndex, row) =>
        row.foreachIndex { (colIndex, cell) =>
          cell match {
            case Number(n) =>
              if (countAdjacentMines(exampleBoard3x3, Pos(rowIndex, colIndex)) != n) {
                countingCorrect = false
              }
            case _ => countingCorrect = countingCorrect // Non-number cells do not need validation
          }
        }
      }
      assertTrue(countingCorrect)
    }

    val (sBoard,pBoard) = replaceMine(beforeRemoveMineSolution, beforeRemoveMinePlayer, Pos(1,2), Pos(1,1))
    test("replaceMine for solution Board"){
      assertEqual(sBoard,afterRemoveMineSolution)
    }
    test("replaceMine for player Board"){
      assertEqual(pBoard,afterRemoveMinePlayer)
    }
    test("neighboursOf only returns positions within bounds of the board"){
      val neighbours: List[Pos] = collectList[Pos]{neighboursOf(3,Pos(0,0),1)}
      assertPosSetEqual(neighbours,[Pos(0,1),Pos(1,1),Pos(1,0)])
    }
    test("nonDiagonalNeighboursOf with radius 0 returns the 4 non diagonal neighbours"){
      val neighbours: List[Pos] = collectList[Pos]{nonDiagonalNeighboursOf(3,Pos(1,1))}
      assertPosSetEqual(neighbours, [Pos(0,1),Pos(1,0),Pos(2,1),Pos(1,2)])
    }
    test("floodfill"){
      assertEqual(floodFill(beforeFloodfillPlayer,floodfillSolution,Pos(3,3)),afterFloodfillPlayer)
    }
    test("calculateProbabilities"){
      assertProbSetEqual(calculateProbabilities(probabilitiesPlayer), [(Pos(1,1),0.0), (Pos(2,1),0.5), (Pos(2,0),0.5), (Pos(1,2),0.5), (Pos(0,2),0.5)])
    }
  })

}